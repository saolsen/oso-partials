<!DOCTYPE html>
<html>
<head>
    <title>App</title>
</head>
<body>
<canvas id="c" width="800" height="600"></canvas>
<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec4 a_position;
    
    void main() {
      gl_Position = a_position;
    } 
</script>
<script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    {{ sdf_function }}

    const vec2 resolution = vec2(800.0, 600.0);

    void main() {
        // get frag coordinates
        vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
        // keep aspect ratio
        uv.x *= resolution.x / resolution.y;

        // camera position and ray direction
        vec3 pos = vec3(0., 0., -3.);
        vec3 dir = normalize(vec3(uv, 1.));

        // ray march
        vec3 ip;

        float t = 0.0;
        for(int i=0; i<32; i++) {
            ip = pos + dir * t;
            float temp = sdf(ip);
            if (temp < 0.01) break;
            t += temp;
        }

        //gl_FragColor = vec4(textureCoord.x, textureCoord.y, 0.0, 1.0);
        gl_FragColor = vec4(ip, 1.0);
    }
</script>
<script type="text/javascript">
    function createShaderFromScriptElement(gl, id, kind) {
        let source = document.getElementById(id).innerHTML;
        let shader = gl.createShader(kind);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    }

    const canvas = document.getElementById('c');
    
    const gl = canvas.getContext("webgl2");
    console.assert(gl != null);

    const vertex_source = document.getElementById("vertex-shader").innerHTML;
    const vertex_shader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertex_shader, vertex_source);
    gl.compileShader(vertex_shader);
    let message = gl.getShaderInfoLog(vertex_shader);
    if (message.length > 0) {
        console.error("Compile Error: ", message)
    }

    const fragment_source = document.getElementById("fragment-shader").innerHTML;
    const fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragment_shader, fragment_source);
    gl.compileShader(fragment_shader);
    message = gl.getShaderInfoLog(fragment_shader);
    if (message.length > 0) {
        console.error("Compile Error: ", message)
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);
    gl.linkProgram(program);
    gl.detachShader(program, vertex_shader);
    gl.detachShader(program, fragment_shader);
    gl.deleteShader(vertex_shader);
    gl.deleteShader(fragment_shader);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        let error = gl.getProgramInfoLog(program);
        console.error("Link Error: ", error);
    }

    gl.useProgram(program);

    var position_location = gl.getAttribLocation(program, "a_position");
    
    const vertex_buffer = gl.createBuffer();
    const vertex_data = new Float32Array([
        1.0, 1.0,
        -1.0, 1.0,
        -1.0, -1.0,
        -1.0, -1.0,
        1.0, -1.0,
        1.0, 1.0
    ]);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(position_location);
    gl.vertexAttribPointer(position_location, 2, gl.FLOAT, false, 0, 0);
    
    // draw
    gl.drawArrays(gl.TRIANGLES, 0, 6);
</script>
</body>
</html>